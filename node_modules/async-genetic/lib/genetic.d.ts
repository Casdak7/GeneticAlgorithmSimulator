export declare const Select: {
    Tournament2: typeof Tournament2;
    Tournament3: typeof Tournament3;
    Fittest: typeof Fittest;
    Random: typeof Random;
    RandomLinearRank: typeof RandomLinearRank;
    Sequential: typeof Sequential;
};
export interface GeneticOptions<T> {
    mutationFunction: (phenotype: T) => T;
    crossoverFunction: (a: T, b: T) => Array<T>;
    fitnessFunction: (phenotype: T) => Promise<number>;
    randomFunction: () => T;
    populationSize: number;
    mutateProbablity?: number;
    crossoverProbablity?: number;
    fittestNSurvives?: number;
    select1?: (pop: any) => T;
    select2?: (pop: any) => T;
    deduplicate?: (phenotype: T) => boolean;
}
export interface Phenotype<T> {
    fitness: number;
    entity: T;
}
export declare class Genetic<T> {
    stats: {};
    options: GeneticOptions<T>;
    protected internalGenState: {};
    private population;
    constructor(options: GeneticOptions<T>);
    /**
     * Startup population, if not passed than will be random generated by randomFunction()
     */
    seed(entities?: Array<T>): void;
    best(count?: number): T[];
    /**
     * Breed population with optional breed settings
     */
    breed(): void;
    /**
     * Estimate population before breeding
     */
    estimate(): Promise<void>;
    /**
     * Sort algorythm
     */
    protected optimize: (a: number, b: number) => boolean;
    /**
     * Try cross a pair or one selected phenotypes
     */
    private tryCrossover;
    /**
     * Try mutate entity with optional probabilty
     */
    private tryMutate;
    /**
     * Mean deviation
     */
    private getMean;
    /**
     * Standart deviation
     */
    private getStdev;
    /**
     * Select one phenotype from population
     */
    private selectOne;
    /**
     * Select two phenotypes from population for crossover
     */
    private selectPair;
    /**
     * Return population without an estimate (fitness)
     */
    private getPurePopulation;
}
/** Utility */
declare function Tournament2<T>(this: Genetic<T>, pop: any): any;
declare function Tournament3<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Fittest<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Random<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function RandomLinearRank<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
declare function Sequential<T>(this: Genetic<T>, pop: Array<Phenotype<T>>): T;
export {};
